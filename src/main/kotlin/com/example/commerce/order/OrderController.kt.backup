package com.example.commerce.order

import com.example.commerce.auth.Auth
import com.example.commerce.auth.AuthProfile
import com.example.commerce.auth.Identities
import com.example.commerce.books.Books
import com.example.commerce.cart.Cart
import com.example.commerce.cart.CartItem
import com.example.commerce.cart.CartItemResponse
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.javatime.*
import org.jetbrains.exposed.sql.transactions.transaction
import org.springframework.data.domain.Page
import org.springframework.data.domain.PageImpl
import org.springframework.data.domain.PageRequest
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import java.sql.Connection
import java.sql.Date

//@Tag(name="주문 처리 API")
@RestController
@RequestMapping("/order")
class OrderController(private val service: OrderService) {

    // 주문 생성
    @Auth
    @PostMapping(value = ["/add"])
    fun create(@RequestBody request: OrderCreateRequest, @RequestAttribute authProfile: AuthProfile):
            ResponseEntity<Long> {

        println("<<< OrderController /order/add >>>")
        println("입력 값 확인")
        println(
            "profileId:" + authProfile.userid.toString() +
                    ",paymentMethod:" + request.paymentMethod +
                    ",paymentPrice:" + request.paymentPrice +
                    ",orderStatus:" + request.orderStatus
        )

        for (bookItem in request.orderItems) {
            "itemId:" + bookItem.itemId +
                    ",quantity:" + bookItem.quantity +
                    ",orderPrice:" + bookItem.orderPrice
        }

        println(
            ",postcode:" + request.orderAddress.postcode +
                    ",address:" + request.orderAddress.address +
                    ",detailAddress:" + request.orderAddress.detailAddress
        )


        // 필요한 request 값이 빈값이면 400 : Bad request
        if (!request.validate()) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(400)
        }

        // 주문 등록 후 orderId return
        val orderId = service.createOrders(request, authProfile)

        return if (orderId > 0) {
            println(
                "주문하기 성공 : 주문번호 : " + orderId
            );

            ResponseEntity.status(HttpStatus.CREATED).body(orderId)
        } else {
            println(
                "주문하기 실패 : 주문번호 : "
            );

            ResponseEntity.status(HttpStatus.CONFLICT).body(orderId)
        }
    }

    // 주문 목록 조회
    @Auth
    @GetMapping("/paging")
    fun paging(
        @RequestParam size: Int, @RequestParam page: Int,
        @RequestParam startDate: String, @RequestParam endDate: String,
        @RequestAttribute authProfile: AuthProfile
    )
            : Page<OrderResponse> = transaction(
        Connection.TRANSACTION_READ_UNCOMMITTED, readOnly = true
    ) {
        println("<<< OrderController /order/list >>>")
        println("입력 값 확인")
        println(
            "size:" + size +
                    ",page:" + page +
                    ",startDate:" + startDate +
                    ",endDate:" + endDate
        )


        val o = Orders // table alias
        val oi = OrderItem // table alias
        val b = Books // table alias

        val query =
            (Orders innerJoin OrderItem)
                .join(Books, JoinType.INNER, onColumn = oi.itemId, otherColumn = b.itemId)
                .slice(
                    Orders.id, Orders.paymentMethod, Orders.paymentPrice, Orders.orderStatus, Orders.orderDate,
                    Books.itemId, Books.title, Books.cover
                )
                .select { (o.id eq oi.orderId) and (o.orderDate >= startDate) }
                .andWhere { o.profileId eq authProfile.id }

        // 페이징 조회
        val result = query
            .orderBy(o.id to SortOrder.DESC)
            .limit(size, offset = (size * page).toLong())
//            .first {  }
            .map { r ->
                OrderResponse(
                    r[Orders.id],
                    r[Orders.paymentMethod],
                    r[Orders.paymentPrice],
                    r[Orders.orderStatus],
                    r[Orders.orderDate].toString(),
                    mutableListOf(
                        OrderItemResponse2(
                            r[o.id],
                            r[Books.itemId],
                            r[Books.title],
                            r[Books.cover]
                        )
                    )
                )
            }

        // 전체 결과 카운트
        val totalCount = query.count()

        return@transaction PageImpl(
            result, // List<OrderResponse>(컬렉션)
            PageRequest.of(page, size), // Pageable
            totalCount // 전체 건수
        )
    }

    @Auth
    @GetMapping("/first-book-orders")
    fun getFirstBookForOrder(
        @RequestParam startDate: String, @RequestParam endDate: String,
        @RequestAttribute authProfile: AuthProfile
    )
            : List<OrderItemResponse2> = transaction(
        Connection.TRANSACTION_READ_UNCOMMITTED, readOnly = true
    ) {
        println("<<< OrderController /order/list >>>")
        println("입력 값 확인")
        println("startDate:" + startDate + ",endDate:" + endDate)

        val o = Orders // table alias
        val oi = OrderItem // table alias
        val b = Books // table alias

        val result =
            (Orders innerJoin OrderItem)
                .join(Books, JoinType.INNER, onColumn = oi.itemId, otherColumn = b.itemId)
                .slice(o.id, b.itemId.min())
                .select { o.id eq oi.orderId }
                .andWhere { o.profileId eq authProfile.id }
                .groupBy(o.id)
                .map { r ->
                    OrderItemResponse2(
                        r[o.id],
                        r[b.itemId],
                        r[b.title],
                        r[b.cover],
                    )
                }


        return@transaction result;
    }

}